---
title: "CSML1000 Group2 Assignment 2 Due this Sunday"
output: github_document
Author: Yuming, Pratik, Madan, Rajiv, Konstantin
Date: October 30, 2019
---

Data Set Information:

The two datasets are related to red and white variants of the Portuguese "Vinho Verde" wine. For more details, consult: [Web Link] or the reference [Cortez et al., 2009]. Due to privacy and logistic issues, only physicochemical (inputs) and sensory (the output) variables are available (e.g. there is no data about grape types, wine brand, wine selling price, etc.).

These datasets can be viewed as classification or regression tasks. The classes are ordered and not balanced (e.g. there are many more normal wines than excellent or poor ones). Outlier detection algorithms could be used to detect the few excellent or poor wines. Also, we are not sure if all input variables are relevant. So it could be interesting to test feature selection methods.


Attribute Information:

For more information, read [Cortez et al., 2009].
Input variables (based on physicochemical tests):
1 - fixed acidity
2 - volatile acidity
3 - citric acid
4 - residual sugar
5 - chlorides
6 - free sulfur dioxide
7 - total sulfur dioxide
8 - density
9 - pH
10 - sulphates
11 - alcohol
Output variable (based on sensory data):
12 - quality (score between 0 and 10)

# Install packages
```{r warning = FALSE}
# install.packages('corrplot', dependencies = TRUE)
# install.packages('cluster', dependencies = TRUE)
# install.packages('factoextra', dependencies = TRUE)
# install.packages('reshape2', dependencies = TRUE)
# install.packages('tidyverse', dependencies = TRUE)
# install.packages('RColorBrewer', dependencies = TRUE)
# install.packages('scales', dependencies = TRUE)
# install.packages('fpc', dependencies = TRUE)
# install.packages('EnvStats', dependencies = TRUE)
# install.packages('NbClust', dependencies = TRUE)
# install.packages('dendextend', dependencies = TRUE)
install.packages('ClusterR', dependencies = TRUE)
```


# Imported library
```{r warning = FALSE}

library(corrplot)
library(cluster)
library(factoextra)
library(reshape2)
library(tidyverse)
library(RColorBrewer)
library(scales)
library(fpc)
library(EnvStats)
library(NbClust)
library(dendextend)
library(gtools)
library(ClusterR)
```

# Load dataset
```{r}
raw <- read.csv('./data/wine-with-type-location.csv', header=TRUE, sep = ";")
#add rowid
raw <- tibble::rowid_to_column(raw, "ROWID")
head(raw, 5)
summary(raw)

#numeric data, last variable is quality which is dependent variable 
data <- raw[c(1:12)]
summary(data)
```

# Structure of data
```{r}
#no NAs or Nans or blanks found
str(data)
nrow(data)
```


# visualizations
```{r}

#Melt data
melt_data = melt(data, id.vars=c("ROWID"))
#visualize spread of data
ggplot(melt_data,  mapping = aes(x = value)) + geom_bar(fill = "#FF6666") + facet_wrap(~variable, scales = 'free_x')

boxplot(data[,-c(1)])

# above shows data needs scaling and has outliers

#checking outliers

#3 outlier
rosnerTest(data$volatile.acidity, k = 4, warn = F)
#0 outliers
rosnerTest(data$citric.acid, k = 4, warn = F)
#4 outliers
rosnerTest(data$residual.sugar, k = 4, warn = F)
#4 outliers
rosnerTest(data$chlorides, k = 4, warn = F)
#4 outliers
rosnerTest(data$free.sulfur.dioxide, k = 4, warn = F)
#0 outliers
rosnerTest(data$density, k = 4, warn = F)
#2 outliers
rosnerTest(data$pH, k = 4, warn = F)
#4 outliers
rosnerTest(data$sulphates, k = 4, warn = F)
#1 outlier
rosnerTest(data$alcohol, k = 4, warn = F)

```


# correlations
```{r}

#corr of data
corrmatrix <- cor(data)
corrplot(corrmatrix, method = 'pie', type="upper")
#moderate corr of 0.6ish for following
#fixed acidity - citric acid
#fixed acidity - density
#free.sulfur.dioxide-total.sulfur.dioxide
#we will remove fixed acidity and total.sulfur
data <- data[-c(1,7)]


#above are visualized and validated via plot
plot(data)


```

# ###########################################################
# Data preparation
# ###########################################################

```{r}
#replace outliers with 5th and 95th percentile values
#remember An outlier is not any point over the 95th percentile 
#or below the 5th percentile. Instead, an outlier is considered so 
#if it is below the first quartile – 1.5·IQR or above third quartile + 1.5·IQR.

capOutlier <- function(x){
   qnt <- quantile(x, probs=c(.25, .75), na.rm = T)
   caps <- quantile(x, probs=c(.05, .95), na.rm = T)
   H <- 1.5 * IQR(x, na.rm = T)
   x[x < (qnt[1] - H)] <- caps[1]
   x[x > (qnt[2] + H)] <- caps[2]
   return(x)
}
data$volatile.acidity=capOutlier(data$volatile.acidity)
data$residual.sugar=capOutlier(data$residual.sugar)
data$chlorides=capOutlier(data$chlorides)
data$total.sulfur.dioxide=capOutlier(data$total.sulfur.dioxide)
data$density=capOutlier(data$density)
data$pH=capOutlier(data$pH)
data$sulphates=capOutlier(data$sulphates)
data$alcohol=capOutlier(data$alcohol)

#scale data
data_scaled <- data.frame(scale(data))

#visualize how well data was scaled
boxplot(data_scaled)
#scaling looks good


```


```{r}
silhouette_score <- function(k){
  km <- kmeans(data, centers = k, nstart=25)
  ss <- silhouette(km$cluster, dist(data_scaled))
  mean(ss[, 3])
}
k <- 2:10
avg_sil <- sapply(k, silhouette_score)
plot(k, type='b', avg_sil, xlab='Number of clusters', ylab='Average Silhouette Scores', frame=FALSE)
```

Show Optimal number of clusters
```{r}
fviz_nbclust(data_scaled, kmeans, method='silhouette')
```


# ###########################################################
# PCA and reduction
# ###########################################################
```{r}

# ##### build pca using princomp
data_pca1 <- princomp(data_scaled)

#examine the importance of PCs
summary(data_pca1)

#inspect principal components
# loadings shows variance and and how much each variable contributes to each components
loadings(data_pca1)
fviz_pca_var(data_pca1,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
             )
# #### above shows that first 8 give us 89% of the variance
# we don't see one variable being overbearing
#plot
plot(data_pca1)
# scree plot
plot(data_pca1, type = "lines")
#biplot
biplot(data_pca1, col = c("gray", "black"))
# ###### using princomp first 10 give us 90% of the variance

# ##### build pca using prcomp
data_pca2 <- prcomp(data_scaled)
summary(data_pca2)
#above shows first 6 account for 88% variance

#plot
plot(data_pca2)
# scree plot
plot(data_pca2, type = "lines")
#biplot
biplot(data_pca2, col = c("gray", "black"))

fviz_pca_var(data_pca2,
             col.var = "contrib", # Color by contributions
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
             )
#above shows first 7 account for 90% variance

# ####PCA didnt really didnt help at all because of the number of components
# We were hoping for a reduction down to 3 - 5 components
#sigh..
#stick with scaled data


```

# ###########################################################
# Clustering using kmeans
# ###########################################################

# determine number of Clusters

```{r}

datatocluster <- data_scaled

# Silhouette method recommends 2
fviz_nbclust(datatocluster, kmeans, method = "silhouette")+
  labs(subtitle = "Silhouette method")

# Elbow method seems to show elbow at 4 or 5 
fviz_nbclust(datatocluster, kmeans, method = "wss")+
  labs(subtitle = "Elbow method")

#gap stat takes some time, uncomment to run it
# Gap statistic recommends 1
set.seed(123)
#fviz_nbclust(datatocluster, kmeans, nstart = 25,  method = "gap_stat", nboot = 50) + labs(subtitle = "Gap statistic method")

#euclidean takes some time, uncomment to run it
#lets also try nbclust using hierarchical clustering
#recommends 4
#NbClust(data = datatocluster, diss = NULL, distance = "euclidean",min.nc = 2, max.nc = 15, method = "ward.D")

# ##### optimal clusters is 4
k=4;

```


```{r}
fit <- kmeans(datatocluster, k, nstart=25, iter.max=200)
fit
# Cluster sizes
sort(table(fit$cluster))
```

# ###########################################################
# visualize and analyze clusters generated by kmeans
# ###########################################################
```{r}
# ####PCA didnt really didnt help at all because of the number of components
# We were hoping for a reduction down to 3 - 5 components
#stick with scaled data

datatovisualize1 <- data_scaled


#clusplot below, but is useless as we performed analysis in 9 dimensions
#clusplot below uses first 2 dimensions which covers 47% variability
#too much overlap in 2d
#should really plot pairs or each variable against cluster
clusplot(datatovisualize1, fit$cluster,cex=1,xlab=colnames(datatovisualize1)[1],ylab=colnames(datatovisualize1)[2],col.p=fit$cluster,lines=0,labels=1)

#pairwise plot
#pairwise keeps running and crashes
#uncomment if need to run
#pairs(datatovisualize1, col=c("red","blue","green","yellow")[fit$cluster])

#put quality back in data
datatovisualize1$quality <- raw$quality

old.par <- par(mar = c(2, 2, 2, 2))
par(mfrow=c(2,2))


for(i in 1:10){
  boxplot(datatovisualize1[,i] ~ fit$cluster,
        xlab='Cluster Number', ylab=colnames(datatovisualize1)[i],
        main=paste('Clusters of ', as.character(colnames(datatovisualize1)[i])))
}
#reset graphics
par(old.par)

#cluster 3 is higher quality than others
#why is that?
# cluster 3: alcohol, pH are higher
# cluster 3: sugar, chlorides, density are lower

#put cluster back into raw data so we can save raw data and show in shiny app
raw$cluster_kmeans=fit$cluster

```


# ###########################################################
# Clustering using Hierarchical Clustering
# ###########################################################

```{r}
#we implement a Ward’s hierarchical clustering procedure:
#distance matrix
d <- dist(data_scaled, method = "euclidean") 
#clustering
h_clust <- hclust(d, method = "ward.D2") 


#display dendrogram with cut rects
plot(h_clust)
rect.hclust(h_clust , k = 5, border = 2:8)
abline(h = 5, col = 'red')

#Display clusters in different colors

avg_dend_obj <- as.dendrogram(h_clust)
avg_col_dend <- color_branches(avg_dend_obj, h =  40)
plot(avg_col_dend)

library(dendextend)
#extract clusters
groups <- cutree(h_clust,k=5)
 
# count number of instances in each group
data_df_cl <- mutate(data, cluster = groups)
count(data_df_cl, cluster)

# We can analysis the quality and
summary(data_df_cl)

ggplot(data_df_cl, aes(x=density, y = residual.sugar , color = factor(cluster))) + geom_point()
clusplot(data_df_cl, fit$cluster,cex=1,xlab=colnames(data_df_cl)[1],ylab=colnames(data_df_cl)[2],col.p=groups,lines=0,labels=1)

```

# ###################################################################
# visualize and analyze clusters generated by hierarchical clustering
# ###################################################################
```{r}
# ####PCA didnt really didnt help at all because of the number of components
# We were hoping for a reduction down to 3 - 5 components
#sigh..
#stick with scaled data

datatovisualize2 <- data_scaled

# 2D representation of the Segmentation:
clusplot(datatovisualize2, groups, main='Clusters')

#pairwise plot
#pairwise keeps running and crashes
#uncomment if need to run
#pairs(datatovisualize2, col=c("red","blue","green","yellow")[groups])

#put quality back in data
datatovisualize2$quality <- raw$quality
par(old.par)
par(mfrow=c(2,2))

for(i in 1:10){
  boxplot(datatovisualize2[,i] ~ groups,
        xlab='Cluster Number', ylab=colnames(datatovisualize2)[i],
        main=paste('Clusters of ', as.character(colnames(datatovisualize2)[i])))
}
#reset graphics
par(old.par)

#cluster 4 is higher quality than others
#why is that?
# cluster 4: alcohol is higher
# cluster 4: chlorides, density are lower

#put cluster back into raw data so we can save raw data and show in shiny app
raw$cluster_hclust=groups
#TODO save data to file to load in shiny


save(raw, file = "./data/shiny.RData")

```


